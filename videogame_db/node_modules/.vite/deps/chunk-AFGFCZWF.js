import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  floating_ui_dom_exports,
  offset,
  shift
} from "./chunk-2EQYT66E.js";
import {
  twJoin,
  twMerge
} from "./chunk-MRTSRWFL.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  compute_rest_props,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_dynamic_element_data,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_slots,
  validate_void_dynamic_element
} from "./chunk-UXNULKQ6.js";

// node_modules/flowbite-svelte/dist/utils/Frame.svelte
var file = "node_modules/flowbite-svelte/dist/utils/Frame.svelte";
function create_dynamic_element(ctx) {
  let svelte_element;
  let use_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  let svelte_element_levels = [
    { role: (
      /*role*/
      ctx[4]
    ) },
    /*$$restProps*/
    ctx[6],
    { class: (
      /*divClass*/
      ctx[5]
    ) }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*tag*/
        ctx[1]
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*tag*/
        (ctx[1] || "null").toUpperCase(),
        { role: true, class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*tag*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file, 82, 0, 3916);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx[18](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(use_action = /*use*/
          ctx[2].call(
            null,
            svelte_element,
            /*options*/
            ctx[3]
          )),
          listen_dev(
            svelte_element,
            "click",
            /*click_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "focusin",
            /*focusin_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "focusout",
            /*focusout_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*tag*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty & /*role*/
        16) && { role: (
          /*role*/
          ctx2[4]
        ) },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*divClass*/
        32) && { class: (
          /*divClass*/
          ctx2[5]
        ) }
      ]));
      if (use_action && is_function(use_action.update) && dirty & /*options*/
      8)
        use_action.update.call(
          null,
          /*options*/
          ctx2[3]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(83:0) <svelte:element this={tag} use:use={options} bind:this={node} {role} {...$$restProps} class={divClass} on:click on:mouseenter on:mouseleave on:focusin on:focusout>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*tag*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*tag*/
    ctx[1]
  );
  let svelte_element = (
    /*tag*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*tag*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*tag*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["tag", "color", "rounded", "border", "shadow", "node", "use", "options", "role"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Frame", slots, ["default"]);
  const noop2 = () => {
  };
  setContext("background", true);
  let { tag = $$restProps.href ? "a" : "div" } = $$props;
  let { color = "default" } = $$props;
  let { rounded = false } = $$props;
  let { border = false } = $$props;
  let { shadow = false } = $$props;
  let { node = void 0 } = $$props;
  let { use = noop2 } = $$props;
  let { options = {} } = $$props;
  let { role = void 0 } = $$props;
  const bgColors = {
    gray: "bg-gray-50 dark:bg-gray-800",
    red: "bg-red-50 dark:bg-gray-800",
    yellow: "bg-yellow-50 dark:bg-gray-800 ",
    green: "bg-green-50 dark:bg-gray-800 ",
    indigo: "bg-indigo-50 dark:bg-gray-800 ",
    purple: "bg-purple-50 dark:bg-gray-800 ",
    pink: "bg-pink-50 dark:bg-gray-800 ",
    blue: "bg-blue-50 dark:bg-gray-800 ",
    light: "bg-gray-50 dark:bg-gray-700",
    dark: "bg-gray-50 dark:bg-gray-800",
    default: "bg-white dark:bg-gray-800",
    dropdown: "bg-white dark:bg-gray-700",
    navbar: "bg-white dark:bg-gray-900",
    navbarUl: "bg-gray-50 dark:bg-gray-800",
    form: "bg-gray-50 dark:bg-gray-700",
    primary: "bg-primary-50 dark:bg-gray-800 ",
    orange: "bg-orange-50 dark:bg-orange-800",
    none: ""
  };
  const textColors = {
    gray: "text-gray-800 dark:text-gray-300",
    red: "text-red-800 dark:text-red-400",
    yellow: "text-yellow-800 dark:text-yellow-300",
    green: "text-green-800 dark:text-green-400",
    indigo: "text-indigo-800 dark:text-indigo-400",
    purple: "text-purple-800 dark:text-purple-400",
    pink: "text-pink-800 dark:text-pink-400",
    blue: "text-blue-800 dark:text-blue-400",
    light: "text-gray-700 dark:text-gray-300",
    dark: "text-gray-700 dark:text-gray-300",
    default: "text-gray-500 dark:text-gray-400",
    dropdown: "text-gray-700 dark:text-gray-200",
    navbar: "text-gray-700 dark:text-gray-200",
    navbarUl: "text-gray-700 dark:text-gray-400",
    form: "text-gray-900 dark:text-white",
    primary: "text-primary-800 dark:text-primary-400",
    orange: "text-orange-800 dark:text-orange-400",
    none: ""
  };
  const borderColors = {
    gray: "border-gray-300 dark:border-gray-800 divide-gray-300 dark:divide-gray-800",
    red: "border-red-300 dark:border-red-800 divide-red-300 dark:divide-red-800",
    yellow: "border-yellow-300 dark:border-yellow-800 divide-yellow-300 dark:divide-yellow-800",
    green: "border-green-300 dark:border-green-800 divide-green-300 dark:divide-green-800",
    indigo: "border-indigo-300 dark:border-indigo-800 divide-indigo-300 dark:divide-indigo-800",
    purple: "border-purple-300 dark:border-purple-800 divide-purple-300 dark:divide-purple-800",
    pink: "border-pink-300 dark:border-pink-800 divide-pink-300 dark:divide-pink-800",
    blue: "border-blue-300 dark:border-blue-800 divide-blue-300 dark:divide-blue-800",
    light: "border-gray-500 divide-gray-500",
    dark: "border-gray-500 divide-gray-500",
    default: "border-gray-200 dark:border-gray-700 divide-gray-200 dark:divide-gray-700",
    dropdown: "border-gray-100 dark:border-gray-600 divide-gray-100 dark:divide-gray-600",
    navbar: "border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700",
    navbarUl: "border-gray-100 dark:border-gray-700 divide-gray-100 dark:divide-gray-700",
    form: "border-gray-300 dark:border-gray-700 divide-gray-300 dark:divide-gray-700",
    primary: "border-primary-500 dark:border-primary-200  divide-primary-500 dark:divide-primary-200 ",
    orange: "border-orange-300 dark:border-orange-800 divide-orange-300 dark:divide-orange-800",
    none: ""
  };
  let divClass;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusin_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(0, node);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("border" in $$new_props)
      $$invalidate(9, border = $$new_props.border);
    if ("shadow" in $$new_props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("node" in $$new_props)
      $$invalidate(0, node = $$new_props.node);
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("options" in $$new_props)
      $$invalidate(3, options = $$new_props.options);
    if ("role" in $$new_props)
      $$invalidate(4, role = $$new_props.role);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    twMerge,
    noop: noop2,
    tag,
    color,
    rounded,
    border,
    shadow,
    node,
    use,
    options,
    role,
    bgColors,
    textColors,
    borderColors,
    divClass
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("color" in $$props)
      $$invalidate(7, color = $$new_props.color);
    if ("rounded" in $$props)
      $$invalidate(8, rounded = $$new_props.rounded);
    if ("border" in $$props)
      $$invalidate(9, border = $$new_props.border);
    if ("shadow" in $$props)
      $$invalidate(10, shadow = $$new_props.shadow);
    if ("node" in $$props)
      $$invalidate(0, node = $$new_props.node);
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("options" in $$props)
      $$invalidate(3, options = $$new_props.options);
    if ("role" in $$props)
      $$invalidate(4, role = $$new_props.role);
    if ("divClass" in $$props)
      $$invalidate(5, divClass = $$new_props.divClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color*/
    128) {
      $:
        $$invalidate(7, color = color ?? "default");
    }
    if ($$self.$$.dirty & /*color*/
    128) {
      $:
        setContext("color", color);
    }
    $:
      $$invalidate(5, divClass = twMerge(bgColors[color], textColors[color], rounded && "rounded-lg", border && "border", borderColors[color], shadow && "shadow-md", $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    node,
    tag,
    use,
    options,
    role,
    divClass,
    $$restProps,
    color,
    rounded,
    border,
    shadow,
    $$scope,
    slots,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    focusin_handler,
    focusout_handler,
    svelte_element_binding
  ];
}
var Frame = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      tag: 1,
      color: 7,
      rounded: 8,
      border: 9,
      shadow: 10,
      node: 0,
      use: 2,
      options: 3,
      role: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Frame",
      options,
      id: create_fragment.name
    });
  }
  get tag() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get node() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Frame_default = Frame;

// node_modules/flowbite-svelte/dist/utils/Popper.svelte
var file2 = "node_modules/flowbite-svelte/dist/utils/Popper.svelte";
function create_if_block_2(ctx) {
  let div;
  const block_1 = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 158, 2, 5670);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[23](div);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[23](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_2.name,
    type: "if",
    source: "(158:0) {#if !referenceEl}",
    ctx
  });
  return block_1;
}
function create_if_block(ctx) {
  let frame;
  let current;
  const frame_spread_levels = [
    { use: (
      /*init*/
      ctx[9]
    ) },
    { options: (
      /*referenceEl*/
      ctx[3]
    ) },
    { role: "tooltip" },
    {
      tabindex: (
        /*activeContent*/
        ctx[1] ? -1 : void 0
      )
    },
    /*$$restProps*/
    ctx[11]
  ];
  let frame_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < frame_spread_levels.length; i += 1) {
    frame_props = assign(frame_props, frame_spread_levels[i]);
  }
  frame = new Frame_default({ props: frame_props, $$inline: true });
  frame.$on("focusin", function() {
    if (is_function(optional(
      /*activeContent*/
      ctx[1],
      /*showHandler*/
      ctx[7]
    )))
      optional(
        /*activeContent*/
        ctx[1],
        /*showHandler*/
        ctx[7]
      ).apply(this, arguments);
  });
  frame.$on("focusout", function() {
    if (is_function(optional(
      /*activeContent*/
      ctx[1],
      /*hideHandler*/
      ctx[8]
    )))
      optional(
        /*activeContent*/
        ctx[1],
        /*hideHandler*/
        ctx[8]
      ).apply(this, arguments);
  });
  frame.$on("mouseenter", function() {
    if (is_function(optional(
      /*activeContent*/
      ctx[1] && !/*clickable*/
      ctx[4],
      /*showHandler*/
      ctx[7]
    )))
      optional(
        /*activeContent*/
        ctx[1] && !/*clickable*/
        ctx[4],
        /*showHandler*/
        ctx[7]
      ).apply(this, arguments);
  });
  frame.$on("mouseleave", function() {
    if (is_function(optional(
      /*activeContent*/
      ctx[1] && !/*clickable*/
      ctx[4],
      /*hideHandler*/
      ctx[8]
    )))
      optional(
        /*activeContent*/
        ctx[1] && !/*clickable*/
        ctx[4],
        /*hideHandler*/
        ctx[8]
      ).apply(this, arguments);
  });
  const block_1 = {
    c: function create() {
      create_component(frame.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(frame.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(frame, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const frame_changes = dirty[0] & /*init, referenceEl, activeContent, $$restProps*/
      2570 ? get_spread_update(frame_spread_levels, [
        dirty[0] & /*init*/
        512 && { use: (
          /*init*/
          ctx[9]
        ) },
        dirty[0] & /*referenceEl*/
        8 && { options: (
          /*referenceEl*/
          ctx[3]
        ) },
        frame_spread_levels[2],
        dirty[0] & /*activeContent*/
        2 && {
          tabindex: (
            /*activeContent*/
            ctx[1] ? -1 : void 0
          )
        },
        dirty[0] & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx[11]
        )
      ]) : {};
      if (dirty[0] & /*$$scope, arrowClass, arrow*/
      16777284) {
        frame_changes.$$scope = { dirty, ctx };
      }
      frame.$set(frame_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(frame.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(frame.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(frame, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block.name,
    type: "if",
    source: "(162:0) {#if open && referenceEl}",
    ctx
  });
  return block_1;
}
function create_if_block_1(ctx) {
  let div;
  let initArrow_action;
  let mounted;
  let dispose;
  const block_1 = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*arrowClass*/
        ctx[6]
      );
      add_location(div, file2, 164, 15, 6113);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(initArrow_action = /*initArrow*/
        ctx[10].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*arrowClass*/
      64) {
        attr_dev(
          div,
          "class",
          /*arrowClass*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_1.name,
    type: "if",
    source: "(165:4) {#if arrow}",
    ctx
  });
  return block_1;
}
function create_default_slot(ctx) {
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    null
  );
  let if_block = (
    /*arrow*/
    ctx[2] && create_if_block_1(ctx)
  );
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[24],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*arrow*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_default_slot.name,
    type: "slot",
    source: '(163:2) <Frame use={init} options={referenceEl} role=\\"tooltip\\" tabindex={activeContent ? -1 : undefined} on:focusin={optional(activeContent, showHandler)} on:focusout={optional(activeContent, hideHandler)} on:mouseenter={optional(activeContent && !clickable, showHandler)} on:mouseleave={optional(activeContent && !clickable, hideHandler)} {...$$restProps}>',
    ctx
  });
  return block_1;
}
function create_fragment2(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = !/*referenceEl*/
  ctx[3] && create_if_block_2(ctx);
  let if_block1 = (
    /*open*/
    ctx[0] && /*referenceEl*/
    ctx[3] && create_if_block(ctx)
  );
  const block_1 = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*referenceEl*/
      ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*open*/
        ctx2[0] && /*referenceEl*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*open, referenceEl*/
          9) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function optional(pred, func) {
  return pred ? func : () => void 0;
}
function instance2($$self, $$props, $$invalidate) {
  let middleware;
  const omit_props_names = [
    "activeContent",
    "arrow",
    "offset",
    "placement",
    "trigger",
    "triggeredBy",
    "reference",
    "strategy",
    "open",
    "yOnly",
    "middlewares"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popper", slots, ["default"]);
  let { activeContent = false } = $$props;
  let { arrow: arrow2 = true } = $$props;
  let { offset: offset2 = 8 } = $$props;
  let { placement = "top" } = $$props;
  let { trigger = "hover" } = $$props;
  let { triggeredBy = void 0 } = $$props;
  let { reference = void 0 } = $$props;
  let { strategy = "absolute" } = $$props;
  let { open = false } = $$props;
  let { yOnly = false } = $$props;
  let { middlewares = [flip(), shift()] } = $$props;
  const dispatch = createEventDispatcher();
  let clickable;
  let hoverable;
  let referenceEl;
  let floatingEl;
  let arrowEl;
  let contentEl;
  let triggerEls = [];
  let _blocked = false;
  const block = () => (_blocked = true, setTimeout(() => _blocked = false, 250));
  const showHandler = (ev) => {
    if (referenceEl === void 0)
      console.error("trigger undefined");
    if (!reference && triggerEls.includes(ev.target) && referenceEl !== ev.target) {
      $$invalidate(3, referenceEl = ev.target);
      block();
    }
    if (clickable && ev.type === "focusin" && !open)
      block();
    $$invalidate(0, open = clickable && ev.type === "click" && !_blocked ? !open : true);
  };
  const hasHover = (el) => el.matches(":hover");
  const hasFocus = (el) => el.contains(document.activeElement);
  const px = (n) => n != null ? `${n}px` : "";
  const hideHandler = (ev) => {
    if (activeContent) {
      setTimeout(
        () => {
          const elements = [referenceEl, floatingEl, ...triggerEls].filter(Boolean);
          if (ev.type === "mouseleave" && elements.some(hasHover))
            return;
          if (ev.type === "focusout" && elements.some(hasFocus))
            return;
          $$invalidate(0, open = false);
        },
        100
      );
    } else
      $$invalidate(0, open = false);
  };
  let arrowSide;
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function updatePosition() {
    computePosition(referenceEl, floatingEl, { placement, strategy, middleware }).then(({ x, y, middlewareData, placement: placement2, strategy: strategy2 }) => {
      floatingEl.style.position = strategy2;
      floatingEl.style.left = yOnly ? "0" : px(x);
      floatingEl.style.top = px(y);
      if (middlewareData.arrow && arrowEl instanceof HTMLDivElement) {
        $$invalidate(20, arrowEl.style.left = px(middlewareData.arrow.x), arrowEl);
        $$invalidate(20, arrowEl.style.top = px(middlewareData.arrow.y), arrowEl);
        $$invalidate(21, arrowSide = oppositeSideMap[placement2.split("-")[0]]);
        $$invalidate(20, arrowEl.style[arrowSide] = px(-arrowEl.offsetWidth / 2 - ($$props.border ? 1 : 0)), arrowEl);
      }
    });
  }
  function init2(node, _referenceEl) {
    floatingEl = node;
    let cleanup = autoUpdate(_referenceEl, floatingEl, updatePosition);
    return {
      update(_referenceEl2) {
        cleanup();
        cleanup = autoUpdate(_referenceEl2, floatingEl, updatePosition);
      },
      destroy() {
        cleanup();
      }
    };
  }
  onMount(() => {
    const events = [
      ["focusin", showHandler, true],
      ["focusout", hideHandler, true],
      ["click", showHandler, clickable],
      ["mouseenter", showHandler, hoverable],
      ["mouseleave", hideHandler, hoverable]
    ];
    if (triggeredBy)
      triggerEls = [...document.querySelectorAll(triggeredBy)];
    else
      triggerEls = contentEl.previousElementSibling ? [contentEl.previousElementSibling] : [];
    if (!triggerEls.length) {
      console.error("No triggers found.");
    }
    triggerEls.forEach((element2) => {
      if (element2.tabIndex < 0)
        element2.tabIndex = 0;
      for (const [name, handler, cond] of events)
        if (cond)
          element2.addEventListener(name, handler);
    });
    if (reference) {
      $$invalidate(3, referenceEl = document.querySelector(reference) ?? document.body);
      if (referenceEl === document.body) {
        console.error(`Popup reference not found: '${reference}'`);
      } else {
        referenceEl.addEventListener("focusout", hideHandler);
        if (hoverable)
          referenceEl.addEventListener("mouseleave", hideHandler);
      }
    } else {
      $$invalidate(3, referenceEl = triggerEls[0]);
    }
    return () => {
      triggerEls.forEach((element2) => {
        if (element2) {
          for (const [name, handler] of events)
            element2.removeEventListener(name, handler);
        }
      });
      if (referenceEl) {
        referenceEl.removeEventListener("focusout", hideHandler);
        referenceEl.removeEventListener("mouseleave", hideHandler);
      }
    };
  });
  let arrowClass;
  function initArrow(node) {
    $$invalidate(20, arrowEl = node);
    return {
      destroy() {
        $$invalidate(20, arrowEl = null);
      }
    };
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(5, contentEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("activeContent" in $$new_props)
      $$invalidate(1, activeContent = $$new_props.activeContent);
    if ("arrow" in $$new_props)
      $$invalidate(2, arrow2 = $$new_props.arrow);
    if ("offset" in $$new_props)
      $$invalidate(12, offset2 = $$new_props.offset);
    if ("placement" in $$new_props)
      $$invalidate(13, placement = $$new_props.placement);
    if ("trigger" in $$new_props)
      $$invalidate(14, trigger = $$new_props.trigger);
    if ("triggeredBy" in $$new_props)
      $$invalidate(15, triggeredBy = $$new_props.triggeredBy);
    if ("reference" in $$new_props)
      $$invalidate(16, reference = $$new_props.reference);
    if ("strategy" in $$new_props)
      $$invalidate(17, strategy = $$new_props.strategy);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("yOnly" in $$new_props)
      $$invalidate(18, yOnly = $$new_props.yOnly);
    if ("middlewares" in $$new_props)
      $$invalidate(19, middlewares = $$new_props.middlewares);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    dom: floating_ui_dom_exports,
    onMount,
    createEventDispatcher,
    twJoin,
    Frame: Frame_default,
    activeContent,
    arrow: arrow2,
    offset: offset2,
    placement,
    trigger,
    triggeredBy,
    reference,
    strategy,
    open,
    yOnly,
    middlewares,
    dispatch,
    clickable,
    hoverable,
    referenceEl,
    floatingEl,
    arrowEl,
    contentEl,
    triggerEls,
    _blocked,
    block,
    showHandler,
    hasHover,
    hasFocus,
    px,
    hideHandler,
    arrowSide,
    oppositeSideMap,
    updatePosition,
    init: init2,
    optional,
    arrowClass,
    initArrow,
    middleware
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), $$new_props));
    if ("activeContent" in $$props)
      $$invalidate(1, activeContent = $$new_props.activeContent);
    if ("arrow" in $$props)
      $$invalidate(2, arrow2 = $$new_props.arrow);
    if ("offset" in $$props)
      $$invalidate(12, offset2 = $$new_props.offset);
    if ("placement" in $$props)
      $$invalidate(13, placement = $$new_props.placement);
    if ("trigger" in $$props)
      $$invalidate(14, trigger = $$new_props.trigger);
    if ("triggeredBy" in $$props)
      $$invalidate(15, triggeredBy = $$new_props.triggeredBy);
    if ("reference" in $$props)
      $$invalidate(16, reference = $$new_props.reference);
    if ("strategy" in $$props)
      $$invalidate(17, strategy = $$new_props.strategy);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("yOnly" in $$props)
      $$invalidate(18, yOnly = $$new_props.yOnly);
    if ("middlewares" in $$props)
      $$invalidate(19, middlewares = $$new_props.middlewares);
    if ("clickable" in $$props)
      $$invalidate(4, clickable = $$new_props.clickable);
    if ("hoverable" in $$props)
      hoverable = $$new_props.hoverable;
    if ("referenceEl" in $$props)
      $$invalidate(3, referenceEl = $$new_props.referenceEl);
    if ("floatingEl" in $$props)
      floatingEl = $$new_props.floatingEl;
    if ("arrowEl" in $$props)
      $$invalidate(20, arrowEl = $$new_props.arrowEl);
    if ("contentEl" in $$props)
      $$invalidate(5, contentEl = $$new_props.contentEl);
    if ("triggerEls" in $$props)
      triggerEls = $$new_props.triggerEls;
    if ("_blocked" in $$props)
      _blocked = $$new_props._blocked;
    if ("arrowSide" in $$props)
      $$invalidate(21, arrowSide = $$new_props.arrowSide);
    if ("arrowClass" in $$props)
      $$invalidate(6, arrowClass = $$new_props.arrowClass);
    if ("middleware" in $$props)
      middleware = $$new_props.middleware;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*trigger*/
    16384) {
      $:
        $$invalidate(4, clickable = trigger === "click");
    }
    if ($$self.$$.dirty[0] & /*trigger*/
    16384) {
      $:
        hoverable = trigger === "hover";
    }
    if ($$self.$$.dirty[0] & /*open*/
    1) {
      $:
        dispatch("show", open);
    }
    if ($$self.$$.dirty[0] & /*placement, referenceEl*/
    8200) {
      $:
        placement && ($$invalidate(3, referenceEl), $$invalidate(13, placement));
    }
    if ($$self.$$.dirty[0] & /*middlewares, offset, arrowEl*/
    1576960) {
      $:
        middleware = [
          ...middlewares,
          offset(+offset2),
          arrowEl && arrow({ element: arrowEl, padding: 10 })
        ];
    }
    $:
      $$invalidate(6, arrowClass = twJoin("absolute pointer-events-none block w-[10px] h-[10px] rotate-45 bg-inherit border-inherit", $$props.border && arrowSide === "bottom" && "border-b border-e", $$props.border && arrowSide === "top" && "border-t border-s ", $$props.border && arrowSide === "right" && "border-t border-e ", $$props.border && arrowSide === "left" && "border-b border-s "));
  };
  $$props = exclude_internal_props($$props);
  return [
    open,
    activeContent,
    arrow2,
    referenceEl,
    clickable,
    contentEl,
    arrowClass,
    showHandler,
    hideHandler,
    init2,
    initArrow,
    $$restProps,
    offset2,
    placement,
    trigger,
    triggeredBy,
    reference,
    strategy,
    yOnly,
    middlewares,
    arrowEl,
    arrowSide,
    slots,
    div_binding,
    $$scope
  ];
}
var Popper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        activeContent: 1,
        arrow: 2,
        offset: 12,
        placement: 13,
        trigger: 14,
        triggeredBy: 15,
        reference: 16,
        strategy: 17,
        open: 0,
        yOnly: 18,
        middlewares: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popper",
      options,
      id: create_fragment2.name
    });
  }
  get activeContent() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeContent(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrow() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrow(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trigger() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trigger(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggeredBy() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggeredBy(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reference() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reference(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strategy() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strategy(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yOnly() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yOnly(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get middlewares() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set middlewares(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popper_default = Popper;

// node_modules/flowbite-svelte/dist/tooltip/Tooltip.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(23:0) <Popper rounded shadow {...$$restProps} class={toolTipClass} on:show>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let popper;
  let current;
  const popper_spread_levels = [
    { rounded: true },
    { shadow: true },
    /*$$restProps*/
    ctx[1],
    { class: (
      /*toolTipClass*/
      ctx[0]
    ) }
  ];
  let popper_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < popper_spread_levels.length; i += 1) {
    popper_props = assign(popper_props, popper_spread_levels[i]);
  }
  popper = new Popper_default({ props: popper_props, $$inline: true });
  popper.$on(
    "show",
    /*show_handler*/
    ctx[5]
  );
  const block = {
    c: function create() {
      create_component(popper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const popper_changes = dirty & /*$$restProps, toolTipClass*/
      3 ? get_spread_update(popper_spread_levels, [
        popper_spread_levels[0],
        popper_spread_levels[1],
        dirty & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty & /*toolTipClass*/
        1 && { class: (
          /*toolTipClass*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        popper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popper.$set(popper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "defaultClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["default"]);
  let { type = "dark" } = $$props;
  let { defaultClass = "py-2 px-3 text-sm font-medium" } = $$props;
  const types = {
    dark: "bg-gray-900 text-white dark:bg-gray-700",
    light: "border-gray-200 bg-white text-gray-900",
    auto: " bg-white text-gray-900 dark:bg-gray-700 dark:text-white border-gray-200 dark:border-gray-700",
    custom: ""
  };
  let toolTipClass;
  function show_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(2, type = $$new_props.type);
    if ("defaultClass" in $$new_props)
      $$invalidate(3, defaultClass = $$new_props.defaultClass);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Popper: Popper_default,
    twMerge,
    type,
    defaultClass,
    types,
    toolTipClass
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("type" in $$props)
      $$invalidate(2, type = $$new_props.type);
    if ("defaultClass" in $$props)
      $$invalidate(3, defaultClass = $$new_props.defaultClass);
    if ("toolTipClass" in $$props)
      $$invalidate(0, toolTipClass = $$new_props.toolTipClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: {
      if ($$restProps.color)
        $$invalidate(2, type = "custom");
      else
        $$invalidate(1, $$restProps.color = "none", $$restProps);
      if (["light", "auto"].includes(type))
        $$invalidate(1, $$restProps.border = true, $$restProps);
      $$invalidate(0, toolTipClass = twMerge("tooltip", defaultClass, types[type], $$props.class));
    }
  };
  $$props = exclude_internal_props($$props);
  return [toolTipClass, $$restProps, type, defaultClass, slots, show_handler, $$scope];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { type: 2, defaultClass: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment3.name
    });
  }
  get type() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultClass() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultClass(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

export {
  Frame_default,
  Popper_default,
  Tooltip_default
};
//# sourceMappingURL=chunk-AFGFCZWF.js.map
